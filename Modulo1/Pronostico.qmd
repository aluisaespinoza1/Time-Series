---
title: "Pronóstico"
format: 
  html:
    embed-resources: true
editor: visual
---

## Forecasts

```{r}
library(tidyverse)
library(fpp3)
```

Let's review this time series for Australian production. You can see that the gas production doesn't have constant variance and needs a mathematical transformation to stabilize it.

Assuming we'll make a forecast for 3 years of Aus production, let's separate our data in train and test.

```{r}
gas_train <- aus_production |> 
  filter_index(. ~ "2007 Q2")
```

Now let's visualize the time series:

```{r}

```

```{r}
gas_train |> 
  autoplot(Gas)
```

Lets use box-cox with Guerrero feature and see the changes.

```{r}
gas_lambda <- gas_train |> 
  features(Gas, features= guerrero) |> 
  pull()

gas_lambda
```

```{r}
gas_train |> 
  autoplot(box_cox(Gas, gas_lambda))
```

**¿Which forecast method is the most appropriate for this time series?**

Note that all the mathematical transformations have to be done inside the fitting function, not before.

```{r}
#tabla con los modelos ajustados
gas_fit <- gas_train |> 
  model(
    drift = RW(box_cox(Gas, gas_lambda) ~ drift()),
    snaive = SNAIVE(box_cox(Gas, gas_lambda)),
    media = MEAN(box_cox(Gas, gas_lambda))
  )

gas_fit

```

Lets make a diagnosis of the models residuals. The function `augment()`, it allows us to obtain the residuals and other adjusted values of the models.

```{r}
gas_aug <- gas_fit |> 
  augment()

gas_aug
```

### **Residual Diagnosis**

A good forecast model will produce residuals with the following characteristics:

1.  **Residuals are not autocorrelated**: if correlations are detected between residuals, there's still useful information yet to be modeled.
2.  **The residuals average is zero:** If the average is different than zero, then the forecast is biased.

Additional to this, the following characteristics are useful, not determinant:

3.  The residuals have a constant variance
4.  The residuals are *normally* distributed

Gráfica de los residuos de los modelos:

```{r}
gas_aug |> 
  autoplot(.innov) +
  facet_wrap(~.model, ncol=1, scales = "free_y")
```

Gráfica edel ACF del residuo de los modelos:

```{r}
gas_aug <- gas_fit |> 
  augment()

gas_aug |> 
  ACF(.innov) |>
  autoplot() +
  facet_wrap(~.model, ncol = 1, scale = "free_y")
```

Gráfica del histograma de los residuos

```{r}
gas_aug |> 
  ggplot(aes(x = .innov, fill = .model)) +
  geom_histogram() +
  facet_wrap(~.model, ncol=1, scales = "free_y")
```

Otra opción

```{r}
gas_fit |> 
  select(drift) |> 
  gg_tsresiduals()
```

```{r}
aus_prod_recent <- aus_production |> 
  filter_index("1999 Q1" ~ .)
```

```{r}
gas_fc <- gas_fit |> 
  forecast(h="3 years") # 12 Q es 3 años, se puede escribir solo 12

gas_fc
```

```{r}
gas_fc |> 
  autoplot(aus_prod_recent) +
  facet_wrap(vars(.model), scale = "free_y", ncol = 1)
```

El modelo seasonal naïve copia y pega el último año, su pronóstico es el igual al último año y no capturó la tendencia de la serie.

$$
MAE = mean (|e_t|)
$$

Estas medidas no pueden usarse para comparar pronósticos entre distintas series por la escala de los datos. Sin embargo, se puede usar el error porcentual como el MAPE, el error absoluto medio porcentual:

$$
MAPE = mean(|P_t|)
$$

```{r}
gas_fc |> 
  accuracy(aus_production) |> 
  arrange(RMSE)
```

# Pronóstico por descomposición

```{r}
gas_train |> 
  model(
    stl = STL(box_cox(Gas, gas_lambda) ~ season(window= "periodic"), robust = TRUE)
  ) |> #robust = true es para que los outliers el efecto se vaya al componente residual
  components() |> 
  autoplot()
```

```{r}
gas_dcmp <- gas_train |> 
  model(
    dcmp = decomposition_model(                                                   #<1>
      STL(box_cox(Gas, gas_lambda) ~ season(window = "periodic"), robust = TRUE), #<2>
      RW(season_adjust ~ drift()),                                                #<3>
      SNAIVE(season_year)                                                         #<4>
    )
  )

gas_dcmp
```

1.  `decomposition_model()` define que se realizará un pronóstico a partir de una descomposición.
2.  Primero se define cómo se realizará la descomposición. En este caso, con STL, con ajuste robusto y con componente estacional periódica.
3.  Luego se define el modelo para la serie desestacionalizada, `season_adjust`.
4.  Finalmente, se define el modelo para la serie estacional, `season_year`. Si este componente no se especifica, R va a utilizar `SNAIVE()` por default.

$H_0: Q = 0$ ➤ No autocorrelación

$H_i: Q ≠ 0$ ➤ Sí hay autocorrelación

Rechazar o no una hipotesis $H_0$ depende de una $\alpha$, donde $\alpha$ es la probabilidad de cometer un error de tipo I (Probabilidad de rechazar $H_0$ cuando es verdadera). El error de tipo II es No rechazar la $H_0$ cuando es falsa.

si p-value \< $\alpha$ rechazo $H_0$

```{r}
#| warning: false
gas_dcmp |> 
  gg_tsresiduals()

```

```{r}
gas_dcmp |> 
  augment() |> 
  features(.innov, ljung_box, lag = 8)

gas_dcmp |> 
  accuracy()
```

```{r}
gas_dcmp_fc <- gas_dcmp |> 
  forecast(h = "3 years")

gas_dcmp_fc 

gas_dcmp_fc |> 
  autoplot(aus_production |> filter_index("1999 Q1" ~ .))


```

```{r}
gas_fc_full <- gas_fc |> 
  full_join(gas_dcmp_fc)

gas_fc_full
```

```{r}
gas_fc_full |> 
  accuracy(aus_production) |> 
  arrange(RMSE)

gas_fc_full |> 
  autoplot(aus_production |> filter_index("1999 Q1" ~ .), level = NULL)
```

```{r}
gas_fit_full <- gas_fit |> 
  cross_join(gas_dcmp) |> 
  mutate(combinado = (snaive + dcmp)/2)

gas_fit_full
```

```{r}
gas_fcst_full <- gas_fit_full |> 
  forecast(h = "3 years")

gas_fcst_full |>
  autoplot(aus_production |> filter_index("1999 Q1" ~ .), level = NULL)

gas_fcst_full |>
  filter(.model == "combinado") |>
  autoplot(aus_production |> filter_index("1999 Q1" ~ .))
```

```{r}
gas_fcst_full |> 
  accuracy(aus_production) |> 
  arrange(RMSE)
```

# ETS

```{r}
ses <- gas_train |> 
  model(
    ses = ETS(Gas ~ error("A") + trend("N") + season("N"))
  )

ses
```

1.  \`ETS()\` es la función para estimar modelos de suavización exponencial y se deben definir 3 argumentos: error, tendencia y estacionalidad.
2.  Tenemos dos opciones: "A" para error aditivo, y "M" para multiplicativo
3.  Para especificar que no queremos ni tendencia, ni estacionalidad, ponemos "N" en ambos casos.

```{r}
report(ses)
```

```{r}
ses |> 
  forecast(h = "3 years") |> 
  autoplot(aus_prod_recent)
```

# Tendencia lineal de HOLT

```{r}
holt <- gas_train |> 
  model(
    holt = ETS(Gas ~ error("A") + trend("A") + season("N"))
  )

holt

report(holt)
```

```{r}
holt |> 
  forecast(h = "3 years") |> 
  autoplot(aus_prod_recent)
```

# Tendencia amortiguada

# Holt winters

```{r}
hw <- gas_train |> 
  model(
    hw = ETS(Gas ~ error("M") + trend("Ad", phi = 0.8) + season("M")) #poner error = estacionalidad
  )

report(hw)

hw |> 
  forecast(h = "3 years") |>
  autoplot(aus_prod_recent)
```

### Comparando modelos

```{r}

STLF <- decomposition_model(
  STL(box_cox(Gas, gas_lambda) ~ season(window = "periodic"), robust=TRUE), 
  RW(season_adjust ~ drift())
) 

STLF_ets <- decomposition_model(
  STL(box_cox(Gas, gas_lambda) ~ season(window = "periodic"), robust=TRUE),
  ETS(season_adjust ~ error("A") + trend("Ad") + season("N"))
)



gas_fit_todos <- gas_train |> 
  model(
    hw = ETS(Gas ~ error("M") + trend("Ad", phi = 0.8) + season("M")),
    snaive = SNAIVE(box_cox(Gas, gas_lambda)),
    hw_boxcox = ETS(box_cox(Gas, lambda = gas_lambda) ~ error("A") + trend("Ad") + season("A")),
    stlf = STLF,
    stlf_ets = STLF_ets
  )

gas_fit_todos
```

```{r}
gas_fc_todos <- gas_fit_todos |> 
  forecast(h = "3 years")

gas_fc_todos |> 
  accuracy(aus_production) |> 
  arrange(RMSE)

p <- gas_fc_todos |> 
  autoplot(aus_prod_recent, level = NULL)

plotly::ggplotly(p)
```
